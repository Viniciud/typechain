import s from"crypto-js/sha256";class t{constructor(s,t,i,n){this.data=void 0,this.index=void 0,this.timestamp=void 0,this.previousHash=void 0,this.hash=void 0,this.nonce=void 0,this.data=s,this.index=t,this.timestamp=i,this.previousHash=n,this.hash=this.calculateHash(),this.nonce=0}calculateHash(){const t=this.index+this.timestamp+JSON.stringify(this.data)+this.nonce+this.previousHash;return s(t).toString()}mineBlock(s){const t=Array(s+1).join("0");let i=0,n=this.calculateHash();for(;n.substring(0,s)!==t;)i++,n=this.calculateHashWithNonce(i);this.nonce=i,this.hash=n,console.log(`Block mined: ${this.hash}`)}calculateHashWithNonce(t){return s(this.index+this.timestamp+JSON.stringify(this.data)+t+this.previousHash).toString()}}class i{constructor(s=4){this.chain=void 0,this.difficulty=void 0,this.pendingTransactions=void 0,this.miningReward=void 0,this.chain=[this.genesisBlock()],this.difficulty=null!=s?s:4,this.pendingTransactions=[],this.miningReward=100}genesisBlock(){return new t(null,0,0,"")}getLastBlock(){return this.chain[this.chain.length-1]}generateBlock(s){let i=this.getLastBlock().index+1,n=(new Date).getTime()/1e3,e=this.getLastBlock().hash;const o=new t(s,i,n,e);return o.mineBlock(this.difficulty),this.isValid()?(console.log("VALIDO"),this.chain.push(o),!0):(console.log("INVALIDO"),!1)}isValid(){if(JSON.stringify(this.genesisBlock())!==JSON.stringify(this.chain[0]))return console.log("GENESIS BLOCK FALSO"),console.log("GEN",JSON.stringify(this.genesisBlock())),console.log("[0]",JSON.stringify(this.chain[0])),!1;for(let s=1;s<this.chain.length;s++){const t=this.chain[s],i=this.chain[s-1];if(t.hash!==t.calculateHash())return console.log("CURRENT BLOCK HASH FALSO"),!1;if(i.hash!==t.previousHash)return console.log("PREVIOUS BLOCK HASH FALSO"),!1}return!0}}class n{constructor(s,t,i=""){this.previousHash=void 0,this.timestamp=void 0,this.transactions=void 0,this.nonce=0,this.hash=this.calculateHash(),this.previousHash=i,this.timestamp=s,this.transactions=t,this.nonce=0,this.hash=this.calculateHash()}calculateHash(){return s(this.previousHash+this.timestamp+JSON.stringify(this.transactions)+this.nonce).toString()}mineBlock(s){const t=Array(s+1).join("0");let i=0,n=this.calculateHash();for(;n.substring(0,s)!==t;)i++,n=this.calculateHashWithNonce(i);this.nonce=i,this.hash=n,console.log(`Block mined: ${this.hash}`)}calculateHashWithNonce(t){return s(this.previousHash+this.timestamp+JSON.stringify(this.transactions)+t).toString()}hasValidTransactions(){for(const s of this.transactions)if(!s.isValid())return!1;return!0}}const e=new(0,require("elliptic").ec)("secp256k1");class o{constructor(s,t,i){this.fromAddress=void 0,this.toAddress=void 0,this.amount=void 0,this.timestamp=void 0,this.signature=null,this.fromAddress=s,this.toAddress=t,this.amount=i,this.timestamp=Date.now()}calculateHash(){return s(this.fromAddress+this.toAddress+this.amount+this.timestamp).toString()}signTransaction(s){if(s.getPublic("hex")!==this.fromAddress)throw new Error("You cannot sign transactions for other wallets!");const t=this.calculateHash(),i=s.sign(t,"base64");this.signature=i.toDER("hex")}isValid(){if(null===this.fromAddress)return!0;if(!this.signature||0===this.signature.length)throw new Error("No signature in this transaction");return e.keyFromPublic(this.fromAddress,"hex").verify(this.calculateHash(),this.signature)}}const a=new(0,require("elliptic").ec)("secp256k1").keyFromPrivate("7c4c45907dec40c91bab3480c39032e90049f1a44f3e18c3e07c23e3273995cf"),r=a.getPublic("hex"),h={local:"Três Corações",data:(new Date).toISOString(),remetente:"BH transporter",destinatario:"Centro de Distribuição Nanico Bufador"};console.log(h);const c=new i,l=new i,d=new class{constructor(s){this.chain=void 0,this.difficulty=void 0,this.pendingTransactions=void 0,this.miningReward=void 0,this.chain=[this.genesisBlock()],this.difficulty=null!=s&&s.difficulty?null==s?void 0:s.difficulty:4,this.pendingTransactions=[],this.miningReward=100}genesisBlock(){return new n(Date.now(),[],"0")}getLastBlock(){return this.chain[this.chain.length-1]}minePendingTransactions(s){const t=new o(null,s,this.miningReward);this.pendingTransactions.push(t);const i=new n(Date.now(),this.pendingTransactions,this.getLastBlock().hash);i.mineBlock(this.difficulty),this.chain.push(i),this.pendingTransactions=[]}addTransaction(s){if(!s.fromAddress||!s.toAddress)throw new Error("Missing (from address) or (to address) in the transaction.");if(!s.isValid())throw new Error("Invalid transaction");if(s.amount<=0)throw new Error("Transaction amount should not to be 0.");const t=this.getBalanceByAddress(s.fromAddress);if(t<s.amount)throw new Error("Not enough balance");const i=this.pendingTransactions.filter(t=>t.fromAddress===s.fromAddress);if(i.length>0&&i.map(s=>s.amount).reduce((s,t)=>s+t)+s.amount>t)throw new Error("Pending transactions for this wallet is higher than its balance.");this.pendingTransactions.push(s)}getBalanceByAddress(s){let t=0;for(const i of this.chain)for(const n of i.transactions)n.fromAddress===s&&(t-=n.amount),n.toAddress===s&&(t+=n.amount);return t}getAllTransactionsForWallet(s){const t=[];for(const i of this.chain)for(const n of i.transactions)n.fromAddress!==s&&n.toAddress!==s||t.push(n);return t}isValid(){if(JSON.stringify(this.genesisBlock())!==JSON.stringify(this.chain[0]))return!1;for(let s=1;s<this.chain.length;s++){const t=this.chain[s],i=this.chain[s-1];if(!t.hasValidTransactions())return!1;if(t.hash!==t.calculateHash())return!1;if(i.hash!==t.previousHash)return!1}return!0}}(8);d.minePendingTransactions(r);const u=new o(r,"myWalletAddress",10);u.signTransaction(a),d.addTransaction(u),d.minePendingTransactions(r),l.generateBlock(h),c.generateBlock(h),console.log("BCHAIN",l),console.log("GENERIC CHAIN",c),console.log("TYPECOIN",d);
//# sourceMappingURL=index.modern.mjs.map
