import s from"crypto-js/sha256";class t{constructor(s,t,i=""){this.previousHash=void 0,this.timestamp=void 0,this.transactions=void 0,this.nonce=0,this.hash=this.calculateHash(),this.previousHash=i,this.timestamp=s,this.transactions=t,this.nonce=0,this.hash=this.calculateHash()}calculateHash(){return s(this.previousHash+this.timestamp+JSON.stringify(this.transactions)+this.nonce).toString()}mineBlock(s){const t=Array(s+1).join("0");let i=0,n=this.calculateHash();for(;n.substring(0,s)!==t;)i++,n=this.calculateHashWithNonce(i);this.nonce=i,this.hash=n,console.log(`Block mined: ${this.hash}`)}calculateHashWithNonce(t){return s(this.previousHash+this.timestamp+JSON.stringify(this.transactions)+t).toString()}hasValidTransactions(){for(const s of this.transactions)if(!s.isValid())return!1;return!0}}const i=new(0,require("elliptic").ec)("secp256k1");class n{constructor(s,t,i){this.fromAddress=void 0,this.toAddress=void 0,this.amount=void 0,this.timestamp=void 0,this.signature=null,this.fromAddress=s,this.toAddress=t,this.amount=i,this.timestamp=Date.now()}calculateHash(){return s(this.fromAddress+this.toAddress+this.amount+this.timestamp).toString()}signTransaction(s){if(s.getPublic("hex")!==this.fromAddress)throw new Error("You cannot sign transactions for other wallets!");const t=this.calculateHash(),i=s.sign(t,"base64");this.signature=i.toDER("hex")}isValid(){if(null===this.fromAddress)return!0;if(!this.signature||0===this.signature.length)throw new Error("No signature in this transaction");return i.keyFromPublic(this.fromAddress,"hex").verify(this.calculateHash(),this.signature)}}class r{constructor(){this.chain=void 0,this.difficulty=8,this.pendingTransactions=void 0,this.miningReward=void 0,this.chain=[this.genesisBlock()],this.difficulty=4,this.pendingTransactions=[],this.miningReward=100}genesisBlock(){return new t(Date.now(),[],"0")}getLastBlock(){return this.chain[this.chain.length-1]}minePendingTransactions(s){const i=new n(null,s,this.miningReward);this.pendingTransactions.push(i);const r=new t(Date.now(),this.pendingTransactions,this.getLastBlock().hash);r.mineBlock(this.difficulty),this.chain.push(r),this.pendingTransactions=[]}addTransaction(s){if(!s.fromAddress||!s.toAddress)throw new Error("Missing (from address) or (to address) in the transaction.");if(!s.isValid())throw new Error("Invalid transaction");if(s.amount<=0)throw new Error("Transaction amount should not to be 0.");const t=this.getBalanceByAddress(s.fromAddress);if(t<s.amount)throw new Error("Not enough balance");const i=this.pendingTransactions.filter(t=>t.fromAddress===s.fromAddress);if(i.length>0&&i.map(s=>s.amount).reduce((s,t)=>s+t)+s.amount>t)throw new Error("Pending transactions for this wallet is higher than its balance.");this.pendingTransactions.push(s)}getBalanceByAddress(s){let t=0;for(const i of this.chain)for(const n of i.transactions)n.fromAddress===s&&(t-=n.amount),n.toAddress===s&&(t+=n.amount);return t}getAllTransactionsForWallet(s){const t=[];for(const i of this.chain)for(const n of i.transactions)n.fromAddress!==s&&n.toAddress!==s||t.push(n);return t}isValid(){if(JSON.stringify(this.genesisBlock())!==JSON.stringify(this.chain[0]))return!1;for(let s=1;s<this.chain.length;s++){const t=this.chain[s],i=this.chain[s-1];if(!t.hasValidTransactions())return!1;if(t.hash!==t.calculateHash())return!1;if(i.hash!==t.previousHash)return!1}return!0}}class a extends r{}class o extends t{}export{o as TypecoinBlock,a as default};
//# sourceMappingURL=index.modern.mjs.map
