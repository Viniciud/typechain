import s from"crypto-js/sha256";class t{constructor(s,t,i=""){this.previousHash=void 0,this.timestamp=void 0,this.transactions=void 0,this.nonce=0,this.hash=this.calculateHash(),this.previousHash=i,this.timestamp=s,this.transactions=t,this.nonce=0,this.hash=this.calculateHash()}calculateHash(){return s(this.previousHash+this.timestamp+JSON.stringify(this.transactions)+this.nonce).toString()}mineBlock(s){for(;this.hash.substring(0,s)!==Array(s+1).join("0");)this.nonce++,this.hash=this.calculateHash()}hasValidTransactions(){for(const s of this.transactions)if(!s.isValid())return!1;return!0}}const i=new(0,require("elliptic").ec)("secp256k1");class n{constructor(s,t,i){this.fromAddress=void 0,this.toAddress=void 0,this.amount=void 0,this.timestamp=void 0,this.signature=null,this.fromAddress=s,this.toAddress=t,this.amount=i,this.timestamp=Date.now()}calculateHash(){return s(this.fromAddress+this.toAddress+this.amount+this.timestamp).toString()}signTransaction(s){if(s.getPublic("hex")!==this.fromAddress)throw new Error("You cannot sign transactions for other wallets!");const t=this.calculateHash(),i=s.sign(t,"base64");this.signature=i.toDER("hex")}isValid(){if(null===this.fromAddress)return!0;if(!this.signature||0===this.signature.length)throw new Error("No signature in this transaction");return i.keyFromPublic(this.fromAddress,"hex").verify(this.calculateHash(),this.signature)}}class a{constructor(){this.chain=void 0,this.difficulty=2,this.pendingTransactions=void 0,this.miningReward=void 0,this.chain=[this.createGenesisBlock()],this.difficulty=2,this.pendingTransactions=[],this.miningReward=100}createGenesisBlock(){return new t(Date.parse("2022-12-21"),[],"0")}getLatestBlock(){return this.chain[this.chain.length-1]}minePendingTransactions(s){const i=new n(null,s,this.miningReward);this.pendingTransactions.push(i);const a=new t(Date.now(),this.pendingTransactions,this.getLatestBlock().hash);a.mineBlock(this.difficulty),this.chain.push(a),this.pendingTransactions=[]}addTransaction(s){if(!s.fromAddress||!s.toAddress)throw new Error("Transaction must include from and to address");if(!s.isValid())throw new Error("Cannot add invalid transaction to chain");if(s.amount<=0)throw new Error("Transaction amount should be higher than 0");const t=this.getBalanceOfAddress(s.fromAddress);if(t<s.amount)throw new Error("Not enough balance");const i=this.pendingTransactions.filter(t=>t.fromAddress===s.fromAddress);if(i.length>0&&i.map(s=>s.amount).reduce((s,t)=>s+t)+s.amount>t)throw new Error("Pending transactions for this wallet is higher than its balance.");this.pendingTransactions.push(s)}getBalanceOfAddress(s){let t=0;for(const i of this.chain)for(const n of i.transactions)n.fromAddress===s&&(t-=n.amount),n.toAddress===s&&(t+=n.amount);return t}getAllTransactionsForWallet(s){const t=[];for(const i of this.chain)for(const n of i.transactions)n.fromAddress!==s&&n.toAddress!==s||t.push(n);return t}isChainValid(){if(JSON.stringify(this.createGenesisBlock())!==JSON.stringify(this.chain[0]))return!1;for(let s=1;s<this.chain.length;s++){const t=this.chain[s];if(this.chain[s-1].hash!==t.previousHash)return!1;if(!t.hasValidTransactions())return!1;if(t.hash!==t.calculateHash())return!1}return!0}}class r extends a{}class e extends t{}export{e as TypecoinBlock,r as default};
