import{createHash as t}from"crypto";class e{constructor(t,e){this.header=void 0,this.payload=void 0,this.header=t,this.payload=e}}function s(){return s=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var o in s)Object.prototype.hasOwnProperty.call(s,o)&&(t[o]=s[o])}return t},s.apply(this,arguments)}var o=0;function i(t){return"__private_"+o+++"_"+t}function n(t,e){if(!Object.prototype.hasOwnProperty.call(t,e))throw new TypeError("attempted to use private field on non-instance");return t}function a(e){return t("sha256").update(JSON.stringify(e)).digest("hex")}function c({hash:t="",difficulty:e=4,prefix:s="0"}){const o=s.repeat(e);return t.startsWith(o)}const r=new(0,require("elliptic").ec)("secp256k1");var l=/*#__PURE__*/i("fromAddress"),h=/*#__PURE__*/i("toAddress"),d=/*#__PURE__*/i("amount"),u=/*#__PURE__*/i("signature"),f=/*#__PURE__*/i("transactionHash");class p{constructor(t,e,s){Object.defineProperty(this,l,{writable:!0,value:void 0}),Object.defineProperty(this,h,{writable:!0,value:void 0}),Object.defineProperty(this,d,{writable:!0,value:void 0}),Object.defineProperty(this,u,{writable:!0,value:null}),Object.defineProperty(this,f,{writable:!0,value:void 0}),n(this,l)[l]=t,n(this,h)[h]=e,n(this,d)[d]=s,n(this,f)[f]=this.calculateHash()}get fromAddress(){return n(this,l)[l]}get toAddress(){return n(this,h)[h]}get amount(){return n(this,d)[d]}calculateHash(){return t("sha256").update(n(this,l)[l]+n(this,h)[h]+n(this,d)[d]).digest("hex").toString()}signTransaction(t){if(t.getPublic("hex")!==n(this,l)[l])throw new Error("You cannot sign transaction for other wallets!");const e=this.calculateHash(),s=t.sign(e,"base64");n(this,u)[u]=s.toDER("hex")}isValid(){if(console.log("SIGNATURE ",n(this,u)[u]),console.log("FROMADDRESS ",n(this,l)[l]),"system"===n(this,l)[l])return!0;if(null===n(this,u)[u]&&"system"!==n(this,l)[l])return!1;if(null==n(this,u)[u]||0===n(this,u)[u].length)return!1;if(this.calculateHash()!==n(this,f)[f])return console.log("HASH diferente "),!1;const t=r.keyFromPublic(n(this,l)[l],"hex");return console.log("IS VALID ",t.verify(this.calculateHash(),n(this,u)[u])),t.verify(this.calculateHash(),n(this,u)[u])}}var g=/*#__PURE__*/i("chain");class y{constructor(t=4){this.difficulty=void 0,Object.defineProperty(this,g,{writable:!0,value:[]}),this.pendingTransactions=[],this.miningReward=1,this.powPrefix="0",this.difficulty=t,n(this,g)[g].push(this.createGenesisBlock())}createGenesisBlock(){const t={sequency:0,timestamp:+new Date,data:[],previousHash:""};return new e({nonce:0,blockHash:a(JSON.stringify(t))},t)}get chain(){return n(this,g)[g]}get lastBlock(){return 1!==this.chain.length?this.chain[this.chain.length-2]:this.chain[0]}lastBlockHash(){return console.log("LasBlockHash ",this.lastBlock.header.blockHash),this.lastBlock.header.blockHash}minePendingTransactions(t){const e=new p("system",t,this.miningReward);this.pendingTransactions.push(e);const s=this.createBlock(this.pendingTransactions),o=this.mineBlock(s);console.log("Block successfully mined!"),console.log("Bloco ",o.minedBlock);for(const t of s.data)console.log("Transactions ",t);this.sendBlock(o.minedBlock),this.pendingTransactions=[]}async addTransaction(t){if(!t.fromAddress||!t.toAddress)throw new Error("Transaction must include from and to adress!");if(!t.isValid())throw console.log("addTransaction"),new Error("Cannot add invalid transaction to chain!");console.log("ENTROU AQUI POR ALGUM MOTIVO"),this.pendingTransactions.push(t)}getBalanceOfAddress(t){let e=0;for(const s of n(this,g)[g])for(const o of s.payload.data)o.fromAddress===t&&(console.log("BLOCK ",s),console.log("TRANSACTIONS ",o),console.log("->"),e-=o.amount,console.log("------------------")),o.toAddress===t&&(console.log("BLOCK ",s),console.log("TRANSACTIONS ",o),console.log("->"),e+=o.amount,console.log("------------------"));return e}createBlock(t){const e={sequency:this.lastBlock.payload.sequency+1,timestamp:+new Date,data:t,previousHash:this.lastBlockHash()};return console.log(`Block #${e.sequency} created: ${JSON.stringify(e)}`),e}mineBlock(t){let e=0;const o=+new Date;for(;;){const i=a(JSON.stringify(t));if(c({hash:a(i+e),difficulty:this.difficulty,prefix:this.powPrefix})){const n=+new Date,a=i.slice(0,12);return console.log(`Block #${t.sequency} mined in ${(n-o)/1e3}s. Hash ${a} (${e} attempts)`),{minedBlock:{payload:s({},t),header:{nonce:e,blockHash:i}}}}e++}}checkBlockTransactions(t){for(const e of t.payload.data)if(!e.isValid())return!1;return!0}checkBlock(t){return this.checkBlockTransactions(t)?(console.log("BLOCK checkBLock ",t),console.log("BLOCK last  ",this.lastBlock),t.payload.previousHash!==this.lastBlockHash()?(console.error(`Block #${t.payload.sequency} it's ${this.lastBlockHash().slice(0,12)} indeed ${t.payload.previousHash.slice(0,12)}`),!1):!!c({hash:a(a(JSON.stringify(t.payload))+t.header.nonce),difficulty:this.difficulty,prefix:this.powPrefix})||(console.error(`Block #${t.payload.sequency} it's invalid! Nonce ${t.header.nonce} it's invalid and can't be checked!`),!1)):(console.log("checkBlock"),!1)}sendBlock(t){return this.checkBlock(t)&&(n(this,g)[g].push(t),console.log(`Block #${t.payload.sequency} has been added into blockchain: ${JSON.stringify(t,null,2)}`)),console.log("FULL CHAIN ",n(this,g)[g]),n(this,g)[g]}}class k extends y{}class B extends e{}export{B as TypecoinBlock,k as default};
