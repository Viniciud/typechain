import s from"crypto-js/sha256";class t{constructor(s,t,i,n){this.index=void 0,this.timestamp=void 0,this.previousHash=void 0,this.data=void 0,this.hash=void 0,this.nonce=void 0,this.index=s,this.timestamp=t,this.previousHash=i,this.data=n,this.hash=this.calculateHash(),this.nonce=0}calculateHash(){const t=this.index+this.timestamp+JSON.stringify(this.data)+this.nonce+this.previousHash;return s(t).toString()}mineBlock(s){const t=Array(s+1).join("0");let i=0,n=this.calculateHash();for(;n.substring(0,s)!==t;)i++,n=this.calculateHashWithNonce(i);this.nonce=i,this.hash=n,console.log(`Block mined: ${this.hash}`)}calculateHashWithNonce(t){return s(this.index+this.timestamp+JSON.stringify(this.data)+t+this.previousHash).toString()}}class i{constructor(s=4){this.chain=void 0,this.difficulty=void 0,this.pendingTransactions=void 0,this.miningReward=void 0,this.chain=[this.genesisBlock()],this.difficulty=null!=s?s:4,this.pendingTransactions=new Array,this.miningReward=100}genesisBlock(){return new t(0,0,"",null)}getLastBlock(){return this.chain[this.chain.length-1]}generateBlock(s){let i=this.getLastBlock().index+1,n=(new Date).getTime()/1e3,a=this.getLastBlock().hash;const e=new t(i,n,a,s);return e.mineBlock(this.difficulty),!!this.isValid()&&(this.chain.push(e),!0)}isValid(){if(JSON.stringify(this.genesisBlock())!==JSON.stringify(this.chain[0]))return!1;for(let s=1;s<this.chain.length;s++){const t=this.chain[s],i=this.chain[s-1];if(t.hash!==t.calculateHash())return!1;if(i.hash!==t.previousHash)return!1}return!0}}class n{constructor(s,t,i=""){this.previousHash=void 0,this.timestamp=void 0,this.transactions=void 0,this.nonce=0,this.hash=this.calculateHash(),this.previousHash=i,this.timestamp=s,this.transactions=t,this.nonce=0,this.hash=this.calculateHash()}calculateHash(t=this.nonce){return s(this.previousHash+this.timestamp+JSON.stringify(this.transactions)+t).toString()}mineBlock(s){const t=Array(s+1).join("0");let i=0,n=this.calculateHash();for(;n.substring(0,s)!==t;)i++,n=this.calculateHash(i);this.nonce=i,this.hash=n,console.log(`Block mined: ${this.hash}`)}validTransactions(){for(const s of this.transactions)if(!s.isValid())return!1;return!0}}const a=new(0,require("elliptic").ec)("secp256k1");class e{constructor(s,t,i){this.fromAddress=void 0,this.toAddress=void 0,this.amount=void 0,this.timestamp=void 0,this.signature=null,this.fromAddress=s,this.toAddress=t,this.amount=i,this.timestamp=Date.now()}calculateHash(){return s(this.fromAddress+this.toAddress+this.amount+this.timestamp).toString()}signTransaction(s){if(s.getPublic("hex")!==this.fromAddress)throw new Error("You cannot sign transactions for other wallets!");const t=this.calculateHash(),i=s.sign(t,"base64");this.signature=i.toDER("hex")}isValid(){if(null===this.fromAddress)return!0;if(!this.signature||0===this.signature.length)throw new Error("No signature in this transaction");return a.keyFromPublic(this.fromAddress,"hex").verify(this.calculateHash(),this.signature)}}class h{constructor(s=4){this.chain=void 0,this.difficulty=void 0,this.pendingTransactions=void 0,this.miningReward=void 0,this.chain=[this.createGenesisBlock()],this.difficulty=s,this.pendingTransactions=new Array,this.miningReward=100}createGenesisBlock(){return new n(Date.now(),[],"0")}getLastBlock(){return this.chain[this.chain.length-1]}minePendingTransactions(s){const t=new e(null,s,this.miningReward);this.pendingTransactions.push(t);const i=new n(Date.now(),this.pendingTransactions,this.getLastBlock().hash);i.mineBlock(this.difficulty),this.chain.push(i),this.pendingTransactions=[]}addTransaction(s){if(!s.fromAddress||!s.toAddress)throw new Error("Missing (from address) or (to address).");if(!s.isValid())throw new Error("Cannot add invalid transaction.");if(s.amount<=0)throw new Error("Transaction amount do not be 0.");const t=this.getBalanceByAddress(s.fromAddress);if(t<s.amount)throw new Error("Balance is not enough.");const i=this.pendingTransactions.filter(t=>t.fromAddress===s.fromAddress);if(i.length>0&&i.map(s=>s.amount).reduce((s,t)=>s+t)+s.amount>t)throw new Error("Pending transactions for this wallet is higher than its balance.");this.pendingTransactions.push(s)}getBalanceByAddress(s){let t=0;for(const i of this.chain)for(const n of i.transactions)n.fromAddress===s&&(t-=n.amount),n.toAddress===s&&(t+=n.amount);return t}getTransactionsByWallet(s){const t=[];for(const i of this.chain)for(const n of i.transactions)n.fromAddress!==s&&n.toAddress!==s||t.push(n);return t}validChain(){if(JSON.stringify(this.createGenesisBlock())!==JSON.stringify(this.chain[0]))return!1;for(let s=1;s<this.chain.length;s++){const t=this.chain[s];if(this.chain[s-1].hash!==t.previousHash)return!1;if(!t.validTransactions())return!1;if(t.hash!==t.calculateHash())return!1}return!0}}class r extends i{}class o extends t{}class c extends h{}class d extends e{}class l extends n{}export{d as TypeTransaction,r as Typechain,o as TypechainBlock,l as TypecoinBlock,c as default};
//# sourceMappingURL=index.modern.mjs.map
