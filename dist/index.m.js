import t from"crypto-js/sha256";function n(t,n){t.prototype=Object.create(n.prototype),t.prototype.constructor=t,i(t,n)}function i(t,n){return i=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t},i(t,n)}function r(t,n){(null==n||n>t.length)&&(n=t.length);for(var i=0,r=new Array(n);i<n;i++)r[i]=t[i];return r}function s(t,n){var i="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(i)return(i=i.call(t)).next.bind(i);if(Array.isArray(t)||(i=function(t,n){if(t){if("string"==typeof t)return r(t,n);var i=Object.prototype.toString.call(t).slice(8,-1);return"Object"===i&&t.constructor&&(i=t.constructor.name),"Map"===i||"Set"===i?Array.from(t):"Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)?r(t,n):void 0}}(t))||n&&t&&"number"==typeof t.length){i&&(t=i);var s=0;return function(){return s>=t.length?{done:!0}:{done:!1,value:t[s++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var e=/*#__PURE__*/function(){function n(t,n,i){void 0===i&&(i=""),this.previousHash=void 0,this.timestamp=void 0,this.transactions=void 0,this.nonce=0,this.hash=this.calculateHash(),this.previousHash=i,this.timestamp=t,this.transactions=n,this.nonce=0,this.hash=this.calculateHash()}var i=n.prototype;return i.calculateHash=function(){return t(this.previousHash+this.timestamp+JSON.stringify(this.transactions)+this.nonce).toString()},i.mineBlock=function(t){for(var n=Array(t+1).join("0"),i=0,r=this.calculateHash();r.substring(0,t)!==n;)i++,r=this.calculateHashWithNonce(i);this.nonce=i,this.hash=r,console.log("Block mined: "+this.hash)},i.calculateHashWithNonce=function(n){return t(this.previousHash+this.timestamp+JSON.stringify(this.transactions)+n).toString()},i.hasValidTransactions=function(){for(var t,n=s(this.transactions);!(t=n()).done;)if(!t.value.isValid())return!1;return!0},n}(),o=new(0,require("elliptic").ec)("secp256k1"),a=/*#__PURE__*/function(){function n(t,n,i){this.fromAddress=void 0,this.toAddress=void 0,this.amount=void 0,this.timestamp=void 0,this.signature=null,this.fromAddress=t,this.toAddress=n,this.amount=i,this.timestamp=Date.now()}var i=n.prototype;return i.calculateHash=function(){return t(this.fromAddress+this.toAddress+this.amount+this.timestamp).toString()},i.signTransaction=function(t){if(t.getPublic("hex")!==this.fromAddress)throw new Error("You cannot sign transactions for other wallets!");var n=this.calculateHash(),i=t.sign(n,"base64");this.signature=i.toDER("hex")},i.isValid=function(){if(null===this.fromAddress)return!0;if(!this.signature||0===this.signature.length)throw new Error("No signature in this transaction");return o.keyFromPublic(this.fromAddress,"hex").verify(this.calculateHash(),this.signature)},n}(),h=/*#__PURE__*/function(t){function i(){return t.apply(this,arguments)||this}return n(i,t),i}(/*#__PURE__*/function(){function t(){this.chain=void 0,this.difficulty=8,this.pendingTransactions=void 0,this.miningReward=void 0,this.chain=[this.genesisBlock()],this.difficulty=4,this.pendingTransactions=[],this.miningReward=100}var n=t.prototype;return n.genesisBlock=function(){return new e(Date.now(),[],"0")},n.getLastBlock=function(){return this.chain[this.chain.length-1]},n.minePendingTransactions=function(t){var n=new a(null,t,this.miningReward);this.pendingTransactions.push(n);var i=new e(Date.now(),this.pendingTransactions,this.getLastBlock().hash);i.mineBlock(this.difficulty),this.chain.push(i),this.pendingTransactions=[]},n.addTransaction=function(t){if(!t.fromAddress||!t.toAddress)throw new Error("Missing (from address) or (to address) in the transaction.");if(!t.isValid())throw new Error("Invalid transaction");if(t.amount<=0)throw new Error("Transaction amount should not to be 0.");var n=this.getBalanceByAddress(t.fromAddress);if(n<t.amount)throw new Error("Not enough balance");var i=this.pendingTransactions.filter(function(n){return n.fromAddress===t.fromAddress});if(i.length>0&&i.map(function(t){return t.amount}).reduce(function(t,n){return t+n})+t.amount>n)throw new Error("Pending transactions for this wallet is higher than its balance.");this.pendingTransactions.push(t)},n.getBalanceByAddress=function(t){for(var n,i=0,r=s(this.chain);!(n=r()).done;)for(var e,o=s(n.value.transactions);!(e=o()).done;){var a=e.value;a.fromAddress===t&&(i-=a.amount),a.toAddress===t&&(i+=a.amount)}return i},n.getAllTransactionsForWallet=function(t){for(var n,i=[],r=s(this.chain);!(n=r()).done;)for(var e,o=s(n.value.transactions);!(e=o()).done;){var a=e.value;a.fromAddress!==t&&a.toAddress!==t||i.push(a)}return i},n.isValid=function(){if(JSON.stringify(this.genesisBlock())!==JSON.stringify(this.chain[0]))return!1;for(var t=1;t<this.chain.length;t++){var n=this.chain[t],i=this.chain[t-1];if(!n.hasValidTransactions())return!1;if(n.hash!==n.calculateHash())return!1;if(i.hash!==n.previousHash)return!1}return!0},t}()),c=/*#__PURE__*/function(t){function i(){return t.apply(this,arguments)||this}return n(i,t),i}(e);export{c as TypecoinBlock,h as default};
//# sourceMappingURL=index.m.js.map
